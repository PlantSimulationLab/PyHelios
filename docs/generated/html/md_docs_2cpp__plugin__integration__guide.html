<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PyHelios: C++ Plugin Integration Guide for PyHelios</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="pyhelios-custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="PyHelios_logo_whiteborder.png"/></td>
  <td id="projectalign">
   <div id="projectname">PyHelios
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_docs_2cpp__plugin__integration__guide.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">C++ Plugin Integration Guide for PyHelios</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a></p>
<p>This guide provides essential information for future agents working on PyHelios to integrate additional C++ plugins and create Python wrappers.</p>
<p><b>IMPORTANT</b>: For a comprehensive step-by-step plugin integration workflow, see the companion Plugin Integration Guide. This guide focuses on the C++ interface and technical implementation details.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Overview</h1>
<p>PyHelios uses a sophisticated plugin architecture that interfaces with native Helios C++ libraries through ctypes. This system enables cross-platform support while maintaining high performance for computationally intensive operations like ray tracing, plant modeling, and physics simulations.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
1. Native Code Build Considerations</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
CMake Build System Integration</h2>
<p><b>Location</b>: <code>pyhelios_build/CMakeLists.txt</code> and <code>pyhelios_build/cmake/PluginSelection.cmake</code></p>
<p><b>Key Requirements:</b></p><ul>
<li>All C++ plugins must be built as shared libraries (<code>.dll</code>, <code>.dylib</code>, <code>.so</code>)</li>
<li>Libraries must export C-compatible functions (use <code>extern "C"</code> wrapper functions)</li>
<li>Plugin dependencies must be properly linked and available at runtime</li>
<li><b>NEW</b>: Plugins must be registered in the flexible plugin selection system</li>
</ul>
<p><b>Plugin Registration:</b> Your plugin must be added to the plugin metadata system (<code><a class="el" href="plugin__metadata_8py.html">pyhelios/config/plugin_metadata.py</a></code>):</p>
<div class="fragment"><div class="line"><span class="stringliteral">&quot;your_plugin&quot;</span>: PluginMetadata(</div>
<div class="line">    name=<span class="stringliteral">&quot;your_plugin&quot;</span>,</div>
<div class="line">    description=<span class="stringliteral">&quot;Description of your plugin functionality&quot;</span>,</div>
<div class="line">    system_dependencies=[<span class="stringliteral">&quot;required_system_libs&quot;</span>],  <span class="comment"># e.g., [&quot;cuda&quot;, &quot;opengl&quot;]</span></div>
<div class="line">    plugin_dependencies=[<span class="stringliteral">&quot;other_plugins&quot;</span>],         <span class="comment"># e.g., [&quot;weberpenntree&quot;]</span></div>
<div class="line">    platforms=[<span class="stringliteral">&quot;windows&quot;</span>, <span class="stringliteral">&quot;linux&quot;</span>, <span class="stringliteral">&quot;macos&quot;</span>],       <span class="comment"># Supported platforms</span></div>
<div class="line">    gpu_required=<span class="keyword">False</span>,                            <span class="comment"># Set True if requires GPU</span></div>
<div class="line">    optional=<span class="keyword">True</span>,                                 <span class="comment"># Set False for core plugins</span></div>
<div class="line">    profile_tags=[<span class="stringliteral">&quot;your_category&quot;</span>],                <span class="comment"># e.g., [&quot;physics&quot;, &quot;modeling&quot;]</span></div>
<div class="line">    test_symbols=[<span class="stringliteral">&quot;test_function_name&quot;</span>]            <span class="comment"># Functions to test availability</span></div>
<div class="line">)</div>
</div><!-- fragment --><p><b>CRITICAL</b>: The <code>test_symbols</code> list should contain function names that will be used to detect plugin availability at runtime. These should be core functions that are guaranteed to exist if the plugin is properly compiled.</p>
<p><b>Add to Plugin Profiles:</b> Also add your plugin to relevant profiles in <code><a class="el" href="plugin__profiles_8py.html">pyhelios/config/plugin_profiles.py</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Add to existing profiles or create new ones</span></div>
<div class="line"><span class="stringliteral">&quot;research&quot;</span>: PluginProfile(</div>
<div class="line">    plugins=[</div>
<div class="line">        <span class="comment"># ... existing plugins ...</span></div>
<div class="line">        <span class="stringliteral">&quot;your_plugin&quot;</span>  <span class="comment"># Add here</span></div>
<div class="line">    ]</div>
<div class="line">),</div>
</div><!-- fragment --><p><b>Critical Build Settings:</b> </p><div class="fragment"><div class="line"># Ensure symbols are exported for ctypes access</div>
<div class="line">set_target_properties(your_plugin PROPERTIES</div>
<div class="line">    CXX_VISIBILITY_PRESET default</div>
<div class="line">    VISIBILITY_INLINES_HIDDEN NO</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"># For Windows DLL export</div>
<div class="line">if(WIN32)</div>
<div class="line">    set_target_properties(your_plugin PROPERTIES</div>
<div class="line">        WINDOWS_EXPORT_ALL_SYMBOLS ON</div>
<div class="line">    )</div>
<div class="line">endif()</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md4"></a>
Library Linking and Dependencies</h2>
<p><b>Static vs Dynamic Linking:</b></p><ul>
<li><b>External dependencies</b> (CUDA, OptiX, OpenGL): Should be dynamically linked when possible</li>
<li><b>Internal Helios components</b>: Can be statically linked into plugin libraries</li>
<li><b>System libraries</b>: Always dynamic (user's system provides them)</li>
</ul>
<p><b>RPATH Configuration (Linux/macOS):</b> </p><div class="fragment"><div class="line"># Set RPATH so libraries can find each other at runtime</div>
<div class="line">set_target_properties(your_plugin PROPERTIES</div>
<div class="line">    INSTALL_RPATH_USE_LINK_PATH TRUE</div>
<div class="line">    INSTALL_RPATH &quot;${CMAKE_INSTALL_PREFIX}/lib&quot;</div>
<div class="line">)</div>
</div><!-- fragment --><p><b>Dependency Management:</b></p><ul>
<li>Use <code>find_package()</code> for external dependencies (CUDA, OptiX, etc.)</li>
<li>Implement graceful degradation when optional dependencies are missing</li>
<li>Copy required runtime files (e.g., <code>.ptx</code> files for CUDA) to installation directory</li>
</ul>
<p><b>Example from Radiation Plugin:</b> </p><div class="fragment"><div class="line"><span class="keyword">def </span>copy_ptx_files(self) -&gt; None:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Copy OptiX PTX files to PyHelios installation directory.&quot;&quot;&quot;</span></div>
<div class="line">    ptx_source_dir = self.build_dir / <span class="stringliteral">&#39;plugins&#39;</span> / <span class="stringliteral">&#39;radiation&#39;</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> ptx_source_dir.exists():</div>
<div class="line">        print(<span class="stringliteral">&quot;No PTX files found - radiation plugin not built with OptiX&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span></div>
<div class="line">    </div>
<div class="line">    ptx_files = list(ptx_source_dir.glob(<span class="stringliteral">&#39;*.ptx&#39;</span>))</div>
<div class="line">    pyhelios_root = self.output_dir.parent.parent</div>
<div class="line">    ptx_dest_dir = pyhelios_root / <span class="stringliteral">&#39;plugins&#39;</span> / <span class="stringliteral">&#39;radiation&#39;</span></div>
<div class="line">    ptx_dest_dir.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> ptx_file <span class="keywordflow">in</span> ptx_files:</div>
<div class="line">        dest_file = ptx_dest_dir / ptx_file.name</div>
<div class="line">        shutil.copy2(ptx_file, dest_file)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md5"></a>
Cross-Platform Symbol Export</h2>
<p><b>C++ Header Structure:</b> </p><div class="fragment"><div class="line"><span class="comment">// your_plugin.h</span></div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor">    #ifdef BUILDING_YOUR_PLUGIN</span></div>
<div class="line"><span class="preprocessor">        #define YOUR_PLUGIN_API __declspec(dllexport)</span></div>
<div class="line"><span class="preprocessor">    #else</span></div>
<div class="line"><span class="preprocessor">        #define YOUR_PLUGIN_API __declspec(dllimport)</span></div>
<div class="line"><span class="preprocessor">    #endif</span></div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor">    #define YOUR_PLUGIN_API __attribute__((visibility(&quot;default&quot;)))</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">    YOUR_PLUGIN_API <span class="keywordtype">void</span> your_function(ContextHandle context, <span class="keywordtype">float</span>* params);</div>
<div class="line">    YOUR_PLUGIN_API <span class="keywordtype">int</span> your_other_function(uint32_t* uuids, <span class="keywordtype">size_t</span> count);</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
2. C++ Interface Implementation</h1>
<h2><a class="anchor" id="autotoc_md7"></a>
Adding Functions to PyHelios C++ Interface</h2>
<p><b>Location</b>: <code>pyhelios_build/pyhelios_interface.cpp</code></p>
<p><b>CRITICAL STEP</b>: Before implementing Python wrappers, you must add C-compatible wrapper functions to the PyHelios interface. This step is often overlooked but is essential for new functionality.</p>
<p><b>Function Implementation Pattern:</b> </p><div class="fragment"><div class="line"><span class="comment">// Add to pyhelios_interface.cpp after existing functions</span></div>
<div class="line">EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addTriangle(helios::Context* context, <span class="keywordtype">float</span>* vertex0, <span class="keywordtype">float</span>* vertex1, <span class="keywordtype">float</span>* vertex2) {</div>
<div class="line">    <span class="keywordflow">if</span> (context &amp;&amp; vertex0 &amp;&amp; vertex1 &amp;&amp; vertex2) {</div>
<div class="line">        helios::vec3 v0(vertex0[0], vertex0[1], vertex0[2]);</div>
<div class="line">        helios::vec3 v1(vertex1[0], vertex1[1], vertex1[2]);</div>
<div class="line">        helios::vec3 v2(vertex2[0], vertex2[1], vertex2[2]);</div>
<div class="line">        <span class="keywordflow">return</span> context-&gt;addTriangle(v0, v1, v2);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">EXPORT <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_function" href="namespacepyhelios_1_1wrappers_1_1UContextWrapper.html#a165d74024c9a1ec70381f7db9da01d80">addTriangleWithColor</a>(helios::Context* context, <span class="keywordtype">float</span>* vertex0, <span class="keywordtype">float</span>* vertex1, <span class="keywordtype">float</span>* vertex2, <span class="keywordtype">float</span>* color) {</div>
<div class="line">    <span class="keywordflow">if</span> (context &amp;&amp; vertex0 &amp;&amp; vertex1 &amp;&amp; vertex2 &amp;&amp; color) {</div>
<div class="line">        helios::vec3 v0(vertex0[0], vertex0[1], vertex0[2]);</div>
<div class="line">        helios::vec3 v1(vertex1[0], vertex1[1], vertex1[2]);</div>
<div class="line">        helios::vec3 v2(vertex2[0], vertex2[1], vertex2[2]);</div>
<div class="line">        helios::RGBcolor color_rgb(color[0], color[1], color[2]);</div>
<div class="line">        <span class="keywordflow">return</span> context-&gt;addTriangle(v0, v1, v2, color_rgb);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="anamespacepyhelios_1_1wrappers_1_1UContextWrapper_html_a165d74024c9a1ec70381f7db9da01d80"><div class="ttname"><a href="namespacepyhelios_1_1wrappers_1_1UContextWrapper.html#a165d74024c9a1ec70381f7db9da01d80">pyhelios.wrappers.UContextWrapper.addTriangleWithColor</a></div><div class="ttdeci">addTriangleWithColor(context, List[float] vertex0, List[float] vertex1, List[float] vertex2, List[float] color)</div><div class="ttdef"><b>Definition</b> <a href="UContextWrapper_8py_source.html#l00516">UContextWrapper.py:516</a></div></div>
</div><!-- fragment --><p><b>Key Interface Requirements:</b></p><ul>
<li>Use <code>EXPORT</code> macro for cross-platform symbol export</li>
<li>Always validate pointer parameters (check for null)</li>
<li>Convert between C arrays and C++ objects (vec3, vec2, etc.)</li>
<li>Return meaningful values (UUIDs, error codes, etc.)</li>
<li>Handle all function overloads that exist in the C++ API</li>
</ul>
<p><b>Parameter Conversion Patterns:</b> </p><div class="fragment"><div class="line"><span class="comment">// vec3 from float array</span></div>
<div class="line">helios::vec3 position(float_array[0], float_array[1], float_array[2]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// vec2 from float array  </span></div>
<div class="line">helios::vec2 size(float_array[0], float_array[1]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// SphericalCoord from float array</span></div>
<div class="line">helios::SphericalCoord rotation = helios::make_SphericalCoord(float_array[0], float_array[1]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Color from float array</span></div>
<div class="line">helios::RGBcolor color(float_array[0], float_array[1], float_array[2]);</div>
<div class="line">helios::RGBAcolor color_rgba(float_array[0], float_array[1], float_array[2], float_array[3]);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// String handling</span></div>
<div class="line">std::string cpp_string(c_string);  <span class="comment">// Automatic conversion</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md8"></a>
Rebuild Requirement</h2>
<p><b>CRITICAL</b>: After adding functions to <code>pyhelios_interface.cpp</code>, you MUST rebuild PyHelios:</p>
<div class="fragment"><div class="line">python3 build_scripts/build_helios.py --verbose</div>
</div><!-- fragment --><p>The build process will:</p><ol type="1">
<li>Recompile the interface with your new functions and exception handling infrastructure</li>
<li>Link everything into the shared library <br  />
</li>
<li>Make the functions available to ctypes</li>
<li>Enable the error management system (<code>_ERROR_MANAGEMENT_AVAILABLE</code> becomes <code>True</code>)</li>
</ol>
<p><b>Verification</b>: After rebuild, the functions should be available and <code>_YOUR_FUNCTIONS_AVAILABLE</code> flags should be <code>True</code>. More importantly, <code>_ERROR_MANAGEMENT_AVAILABLE</code> should be <code>True</code>, enabling proper exception handling.</p>
<p><b>Exception Handling Activation</b>: The comprehensive exception handling system requires the C++ library to be compiled with the new error management infrastructure. Until recompilation:</p><ul>
<li>Basic PyHelios functionality works normally</li>
<li>Exception handling tests are automatically skipped</li>
<li>Some operations may still cause SIGABRT crashes instead of Python exceptions</li>
<li>After recompilation, all C++ exceptions become proper Python exceptions</li>
</ul>
<h1><a class="anchor" id="autotoc_md9"></a>
3. Python Wrapper Implementation</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
Wrapper Architecture</h2>
<p><b>Location</b>: <code>pyhelios/wrappers/UYourPluginWrapper.py</code> or existing wrapper files</p>
<p><b>Template Structure:</b> </p><div class="fragment"><div class="line"><span class="keyword">import</span> ctypes</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Optional</div>
<div class="line"><span class="keyword">from</span> ..plugins <span class="keyword">import</span> helios_lib</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define plugin-specific data structures</span></div>
<div class="line"><span class="keyword">class </span>UYourPluginStruct(ctypes.Structure):</div>
<div class="line">    <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Declare function prototypes</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    helios_lib.your_function.argtypes = [</div>
<div class="line">        ctypes.POINTER(UContext), </div>
<div class="line">        ctypes.POINTER(ctypes.c_float)</div>
<div class="line">    ]</div>
<div class="line">    helios_lib.your_function.restype = ctypes.c_int</div>
<div class="line">    </div>
<div class="line">    _YOUR_PLUGIN_FUNCTIONS_AVAILABLE = <span class="keyword">True</span></div>
<div class="line"><span class="keywordflow">except</span> AttributeError:</div>
<div class="line">    _YOUR_PLUGIN_FUNCTIONS_AVAILABLE = <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>your_function_wrapper(context, params: List[float]) -&gt; int:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Wrapper for your C++ function&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _YOUR_PLUGIN_FUNCTIONS_AVAILABLE:</div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line">            <span class="stringliteral">&quot;Your plugin functions not available in current Helios library. &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;Rebuild with your plugin enabled.&quot;</span></div>
<div class="line">        )</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Convert Python types to ctypes</span></div>
<div class="line">    param_array = (ctypes.c_float * len(params))(*params)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Call C++ function</span></div>
<div class="line">    result = helios_lib.your_function(context, param_array)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Handle errors</span></div>
<div class="line">    <span class="keywordflow">if</span> result != 0:</div>
<div class="line">        <span class="keywordflow">raise</span> RuntimeError(f<span class="stringliteral">&quot;Your plugin function failed with error code: {result}&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> result</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md11"></a>
Critical ctypes Mapping Rules</h2>
<p><b>Python Type → ctypes Type:</b> </p><div class="fragment"><div class="line"><span class="comment"># Scalars</span></div>
<div class="line">int → ctypes.c_int, ctypes.c_uint, ctypes.c_size_t</div>
<div class="line">float → ctypes.c_float, ctypes.c_double  </div>
<div class="line">bool → ctypes.c_bool</div>
<div class="line">str → ctypes.c_char_p (encode to UTF-8 first!)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Arrays</span></div>
<div class="line">List[int] → (ctypes.c_int * len(list))(*list)</div>
<div class="line">List[float] → (ctypes.c_float * len(list))(*list)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pointers (for output parameters)</span></div>
<div class="line">ctypes.POINTER(ctypes.c_float)  <span class="comment"># For returning single float</span></div>
<div class="line">ctypes.POINTER(ctypes.c_int)    <span class="comment"># For returning single int</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Strings (CRITICAL)</span></div>
<div class="line">my_string.encode(<span class="stringliteral">&#39;utf-8&#39;</span>)  <span class="comment"># Always encode Python strings!</span></div>
</div><!-- fragment --><p><b>Memory Management:</b> </p><div class="fragment"><div class="line"><span class="comment"># For functions that return dynamically allocated arrays</span></div>
<div class="line"><span class="keyword">def </span>get_array_wrapper(context, uuid: int) -&gt; List[float]:</div>
<div class="line">    size = ctypes.c_uint()</div>
<div class="line">    ptr = helios_lib.get_array_function(context, uuid, ctypes.byref(size))</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Convert C array to Python list</span></div>
<div class="line">    result = list(ptr[:size.value])</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Important: Let C++ manage memory - don&#39;t call free() from Python</span></div>
<div class="line">    <span class="comment"># unless the C++ API explicitly requires it</span></div>
<div class="line">    <span class="keywordflow">return</span> result</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md12"></a>
Error Handling Patterns</h2>
<p><b>CRITICAL: Exception Handling Infrastructure</b></p>
<p>PyHelios implements comprehensive exception handling to convert C++ exceptions into proper Python exceptions. When adding new functions, you MUST follow the error handling patterns to maintain PyHelios's fail-fast philosophy.</p>
<p><b>UPDATED: New Error Handling Methodology</b></p>
<p>PyHelios now uses a simplified, robust error handling system that automatically converts C++ exceptions to Python exceptions through errcheck callbacks.</p>
<p><b>C++ Wrapper Exception Handling:</b> </p><div class="fragment"><div class="line"><span class="comment">// In your C++ wrapper functions (pyhelios_wrapper.cpp)</span></div>
<div class="line"><span class="preprocessor">#include &quot;pyhelios_wrapper.h&quot;</span>  <span class="comment">// Includes error management infrastructure</span></div>
<div class="line"> </div>
<div class="line">uint32_t your_new_function(helios::Context* context, <span class="keywordtype">float</span>* params, uint32_t param_count) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        clearError(); <span class="comment">// Clear any previous error</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Always validate parameters first</span></div>
<div class="line">        <span class="keywordflow">if</span> (!context) {</div>
<div class="line">            setError(1, <span class="stringliteral">&quot;Context pointer is null&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (!params) {</div>
<div class="line">            setError(1, <span class="stringliteral">&quot;Parameters array is null&quot;</span>);</div>
<div class="line">            <span class="keywordflow">return</span> 0;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Your actual C++ API call that might throw exceptions</span></div>
<div class="line">        <span class="keywordflow">return</span> context-&gt;your_cpp_method(params, param_count);</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">        <span class="comment">// Use error code based on exception type - preserve exact Helios error message</span></div>
<div class="line">        setError(7, e.what()); <span class="comment">// Error code 7 = PYHELIOS_ERROR_RUNTIME</span></div>
<div class="line">        <span class="keywordflow">return</span> 0; <span class="comment">// Return default value, error will be checked by Python errcheck</span></div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        <span class="comment">// Use error code 7 for general runtime errors</span></div>
<div class="line">        setError(7, std::string(<span class="stringliteral">&quot;ERROR (YourFunction): &quot;</span>) + e.what());</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">// Use error code 99 for unknown errors</span></div>
<div class="line">        setError(99, <span class="stringliteral">&quot;ERROR (YourFunction): Unknown error.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// For functions returning pointers</span></div>
<div class="line"><span class="keywordtype">float</span>* get_array_function(helios::Context* context, uint32_t uuid, uint32_t* size) {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        clearError(); <span class="comment">// Clear any previous error</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (!context || !size) {</div>
<div class="line">            setError(1, <span class="stringliteral">&quot;Invalid parameters&quot;</span>);</div>
<div class="line">            <span class="keywordflow">if</span> (size) *size = 0;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;float&gt; result = context-&gt;get_array_method(uuid);</div>
<div class="line">        <span class="comment">// Convert vector to C array and return</span></div>
<div class="line">        <span class="keyword">static</span> std::vector&lt;float&gt; static_result;</div>
<div class="line">        static_result = result;</div>
<div class="line">        *size = static_result.size();</div>
<div class="line">        <span class="keywordflow">return</span> static_result.data();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::runtime_error&amp; e) {</div>
<div class="line">        setError(2, e.what()); <span class="comment">// Error code 2 = UUID_NOT_FOUND for typical cases</span></div>
<div class="line">        <span class="keywordflow">if</span> (size) *size = 0;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        setError(7, e.what());</div>
<div class="line">        <span class="keywordflow">if</span> (size) *size = 0;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    } <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        setError(99, <span class="stringliteral">&quot;ERROR (GetArrayFunction): Unknown error.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">if</span> (size) *size = 0;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Python Wrapper Exception Handling:</b> </p><div class="fragment"><div class="line"><span class="comment"># Import exception checking infrastructure</span></div>
<div class="line"><span class="keyword">from</span> ..exceptions <span class="keyword">import</span> check_helios_error</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Error management function prototypes</span></div>
<div class="line">helios_lib.getLastErrorCode.restype = ctypes.c_int</div>
<div class="line">helios_lib.getLastErrorMessage.restype = ctypes.c_char_p</div>
<div class="line">helios_lib.clearError.argtypes = []</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Automatic error checking callback</span></div>
<div class="line"><span class="keyword">def </span>_check_error(result, func, args):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Errcheck callback that automatically checks for Helios errors after each function call.</span></div>
<div class="line"><span class="stringliteral">    This ensures that C++ exceptions are properly converted to Python exceptions.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    check_helios_error(helios_lib.getLastErrorCode, helios_lib.getLastErrorMessage)</div>
<div class="line">    <span class="keywordflow">return</span> result</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Function prototype with automatic error checking</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    helios_lib.your_function.argtypes = [ctypes.POINTER(UContext), ctypes.POINTER(ctypes.c_float), ctypes.c_uint]</div>
<div class="line">    helios_lib.your_function.restype = ctypes.c_uint</div>
<div class="line">    helios_lib.your_function.errcheck = _check_error  <span class="comment"># CRITICAL: This enables automatic error checking</span></div>
<div class="line">    _YOUR_FUNCTION_AVAILABLE = <span class="keyword">True</span></div>
<div class="line"><span class="keywordflow">except</span> AttributeError:</div>
<div class="line">    _YOUR_FUNCTION_AVAILABLE = <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified function wrapper - errcheck handles all error checking</span></div>
<div class="line"><span class="keyword">def </span>your_function_wrapper(context, params: List[float]) -&gt; int:</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _YOUR_FUNCTION_AVAILABLE:</div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line">            <span class="stringliteral">&quot;Your plugin functions not available in current Helios library. &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;Rebuild with your plugin enabled.&quot;</span></div>
<div class="line">        )</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Convert Python types to ctypes</span></div>
<div class="line">    param_array = (ctypes.c_float * len(params))(*params)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Call C++ function - errcheck automatically handles error checking</span></div>
<div class="line">    result = helios_lib.your_function(context, param_array, len(params))</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># No manual error checking needed - errcheck handles everything automatically</span></div>
<div class="line">    <span class="keywordflow">return</span> result</div>
</div><!-- fragment --><p><b>Function Availability Checking:</b> </p><div class="fragment"><div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    helios_lib.your_new_function.argtypes = [...]</div>
<div class="line">    _NEW_FUNCTION_AVAILABLE = <span class="keyword">True</span></div>
<div class="line"><span class="keywordflow">except</span> AttributeError:</div>
<div class="line">    _NEW_FUNCTION_AVAILABLE = <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>wrapper_function(...):</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _NEW_FUNCTION_AVAILABLE:</div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line">            <span class="stringliteral">&quot;Function requires newer Helios library version. &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;Rebuild PyHelios with updated helios-core.&quot;</span></div>
<div class="line">        )</div>
</div><!-- fragment --><p><b>Robust Parameter Validation:</b> </p><div class="fragment"><div class="line"><span class="keyword">def </span>your_wrapper(uuids: List[int], data: str, threshold: float):</div>
<div class="line">    <span class="comment"># Validate inputs before C++ call</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> uuids:</div>
<div class="line">        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;UUID list cannot be empty&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> data:</div>
<div class="line">        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Data label cannot be empty&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> threshold &lt; 0:</div>
<div class="line">        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Threshold must be non-negative&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Convert and validate types</span></div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        uuid_array = (ctypes.c_uint * len(uuids))(*uuids)</div>
<div class="line">        data_encoded = data.encode(<span class="stringliteral">&#39;utf-8&#39;</span>)</div>
<div class="line">        threshold_c = ctypes.c_float(threshold)</div>
<div class="line">    <span class="keywordflow">except</span> (TypeError, ValueError, UnicodeEncodeError) <span class="keyword">as</span> e:</div>
<div class="line">        <span class="keywordflow">raise</span> ValueError(f<span class="stringliteral">&quot;Parameter conversion failed: {e}&quot;</span>)</div>
</div><!-- fragment --><p><b>NEVER Do Silent Fallbacks:</b> </p><div class="fragment"><div class="line"><span class="comment"># ❌ WRONG - Silent fallback (violates fail-fast philosophy)</span></div>
<div class="line"><span class="keyword">def </span>bad_wrapper(context, uuid: int):</div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="keywordflow">return</span> helios_lib.some_function(context, uuid)</div>
<div class="line">    <span class="keywordflow">except</span>:</div>
<div class="line">        <span class="keywordflow">return</span> 0  <span class="comment"># Silent failure - user doesn&#39;t know what went wrong</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ✅ CORRECT - Fail-fast with clear error messages  </span></div>
<div class="line"><span class="keyword">def </span>good_wrapper(context, uuid: int):</div>
<div class="line">    result = helios_lib.some_function(context, uuid)</div>
<div class="line">    _check_for_helios_error()  <span class="comment"># Will raise appropriate exception</span></div>
<div class="line">    <span class="keywordflow">return</span> result</div>
</div><!-- fragment --><p><b>Available Exception Types:</b></p>
<p>PyHelios provides a hierarchy of exception types that map to specific C++ error categories:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> <a class="code hl_namespace" href="namespacepyhelios_1_1exceptions.html">pyhelios.exceptions</a> <span class="keyword">import</span> (</div>
<div class="line">    HeliosError,                    <span class="comment"># Base exception for all PyHelios errors</span></div>
<div class="line">    HeliosRuntimeError,             <span class="comment"># C++ std::runtime_error (most common)</span></div>
<div class="line">    HeliosInvalidArgumentError,     <span class="comment"># Invalid parameters, null pointers</span></div>
<div class="line">    HeliosUUIDNotFoundError,        <span class="comment"># Accessing non-existent primitives</span></div>
<div class="line">    HeliosFileIOError,              <span class="comment"># File loading/saving errors</span></div>
<div class="line">    HeliosMemoryAllocationError,    <span class="comment"># Memory allocation failures</span></div>
<div class="line">    HeliosGPUInitializationError,   <span class="comment"># GPU/OptiX initialization failures</span></div>
<div class="line">    HeliosPluginNotAvailableError,  <span class="comment"># Plugin not compiled/available</span></div>
<div class="line">    HeliosUnknownError             <span class="comment"># Unexpected C++ exceptions</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Exception mapping is automatic - C++ error codes are converted to appropriate Python exceptions</span></div>
<div class="line"><span class="comment"># You don&#39;t need to manually choose exception types when using _check_for_helios_error()</span></div>
<div class="ttc" id="anamespacepyhelios_1_1exceptions_html"><div class="ttname"><a href="namespacepyhelios_1_1exceptions.html">pyhelios.exceptions</a></div><div class="ttdef"><b>Definition</b> <a href="exceptions_8py_source.html#l00001">exceptions.py:1</a></div></div>
</div><!-- fragment --><p><b>Error Code Constants (C++ side):</b> </p><div class="fragment"><div class="line"><span class="comment">// These are automatically defined in pyhelios_wrapper.h</span></div>
<div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> {</div>
<div class="line">    PYHELIOS_SUCCESS = 0,</div>
<div class="line">    PYHELIOS_ERROR_INVALID_PARAMETER = 1,     <span class="comment">// → HeliosInvalidArgumentError</span></div>
<div class="line">    PYHELIOS_ERROR_UUID_NOT_FOUND = 2,        <span class="comment">// → HeliosUUIDNotFoundError  </span></div>
<div class="line">    PYHELIOS_ERROR_FILE_IO = 3,               <span class="comment">// → HeliosFileIOError</span></div>
<div class="line">    PYHELIOS_ERROR_MEMORY_ALLOCATION = 4,     <span class="comment">// → HeliosMemoryAllocationError</span></div>
<div class="line">    PYHELIOS_ERROR_GPU_INITIALIZATION = 5,    <span class="comment">// → HeliosGPUInitializationError</span></div>
<div class="line">    PYHELIOS_ERROR_PLUGIN_NOT_AVAILABLE = 6,  <span class="comment">// → HeliosPluginNotAvailableError</span></div>
<div class="line">    PYHELIOS_ERROR_RUNTIME = 7,               <span class="comment">// → HeliosRuntimeError</span></div>
<div class="line">    PYHELIOS_ERROR_UNKNOWN = 99               <span class="comment">// → HeliosUnknownError</span></div>
<div class="line">} PyHeliosErrorCode;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md13"></a>
High-Level Python API Integration</h2>
<p><b>Location</b>: <code>pyhelios/YourPlugin.py</code></p>
<p><b>Class Structure Pattern:</b> </p><div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Optional, Union</div>
<div class="line"><span class="keyword">from</span> . <span class="keyword">import</span> wrappers.UYourPluginWrapper <span class="keyword">as</span> plugin_wrapper</div>
<div class="line"><span class="keyword">from</span> .Context <span class="keyword">import</span> Context</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>YourPlugin:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;High-level interface for your C++ plugin&quot;&quot;&quot;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__init__(self, context: Context):</div>
<div class="line">        self.context = context</div>
<div class="line">        self._plugin_handle = plugin_wrapper.create_your_plugin(context.context)</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__enter__(self):</div>
<div class="line">        <span class="keywordflow">return</span> self</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>__exit__(self, exc_type, exc_val, exc_tb):</div>
<div class="line">        <span class="keywordflow">if</span> hasattr(self, <span class="stringliteral">&#39;_plugin_handle&#39;</span>):</div>
<div class="line">            plugin_wrapper.destroy_your_plugin(self._plugin_handle)</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>your_method(self, param1: float, param2: List[int]) -&gt; List[float]:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">        High-level method with clear documentation.</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">        Args:</span></div>
<div class="line"><span class="stringliteral">            param1: Description of parameter</span></div>
<div class="line"><span class="stringliteral">            param2: List of primitive UUIDs</span></div>
<div class="line"><span class="stringliteral">            </span></div>
<div class="line"><span class="stringliteral">        Returns:</span></div>
<div class="line"><span class="stringliteral">            List of computed values</span></div>
<div class="line"><span class="stringliteral">            </span></div>
<div class="line"><span class="stringliteral">        Raises:</span></div>
<div class="line"><span class="stringliteral">            RuntimeError: If computation fails</span></div>
<div class="line"><span class="stringliteral">            ValueError: If parameters are invalid</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> plugin_wrapper.your_function_wrapper(</div>
<div class="line">            self._plugin_handle, param1, param2</div>
<div class="line">        )</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md14"></a>
3. Additional Important Considerations</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
Platform-Specific Considerations</h2>
<p><b>Windows:</b></p><ul>
<li>Ensure all DLL dependencies are in PATH or same directory</li>
<li>Use <code>ctypes.WinDLL</code> for stdcall functions, <code>ctypes.CDLL</code> for cdecl</li>
<li>Be aware of Visual Studio runtime requirements</li>
</ul>
<p><b>Linux/macOS:</b> <br  />
</p><ul>
<li>Set proper RPATH so shared libraries can find dependencies</li>
<li>Handle different library naming conventions (<code>.so</code> vs <code>.dylib</code>)</li>
<li>Consider different compiler ABI compatibility</li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
Testing Integration</h2>
<p><b>Mock Mode Support:</b> </p><div class="fragment"><div class="line"><span class="comment"># In your wrapper file</span></div>
<div class="line"><span class="keywordflow">if</span> <span class="keywordflow">not</span> _YOUR_PLUGIN_FUNCTIONS_AVAILABLE:</div>
<div class="line">    <span class="keyword">def </span>mock_your_function(*args, **kwargs):</div>
<div class="line">        <span class="keywordflow">raise</span> RuntimeError(</div>
<div class="line">            <span class="stringliteral">&quot;Mock mode: Your plugin not available. &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;This would perform [specific operation] with native library.&quot;</span></div>
<div class="line">        )</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Replace wrapper functions with mocks</span></div>
<div class="line">    your_function_wrapper = mock_your_function</div>
</div><!-- fragment --><p><b>Test Structure:</b> </p><div class="fragment"><div class="line"><span class="comment"># tests/test_your_plugin.py</span></div>
<div class="line"><span class="keyword">import</span> pytest</div>
<div class="line"><span class="keyword">from</span> pyhelios <span class="keyword">import</span> Context, YourPlugin</div>
<div class="line"><span class="keyword">from</span> <a class="code hl_namespace" href="namespacepyhelios_1_1exceptions.html">pyhelios.exceptions</a> <span class="keyword">import</span> HeliosError, HeliosInvalidArgumentError</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.native_only</span></div>
<div class="line"><span class="keyword">def </span>test_your_plugin_basic():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test requiring actual native library&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">with</span> Context() <span class="keyword">as</span> context:</div>
<div class="line">        <span class="keyword">with</span> YourPlugin(context) <span class="keyword">as</span> plugin:</div>
<div class="line">            result = plugin.your_method(1.0, [1, 2, 3])</div>
<div class="line">            <span class="keyword">assert</span> len(result) == 3</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.cross_platform</span>  </div>
<div class="line"><span class="keyword">def </span>test_your_plugin_mock():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test that works in mock mode&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">with</span> Context() <span class="keyword">as</span> context:</div>
<div class="line">        <span class="comment"># This should work in mock mode for API validation</span></div>
<div class="line">        plugin = YourPlugin(context)  <span class="comment"># Don&#39;t call actual methods</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.cross_platform</span></div>
<div class="line"><span class="keyword">def </span>test_your_plugin_exception_handling():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test that proper exceptions are raised for invalid inputs&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">with</span> Context() <span class="keyword">as</span> context:</div>
<div class="line">        <span class="keyword">with</span> YourPlugin(context) <span class="keyword">as</span> plugin:</div>
<div class="line">            <span class="comment"># Test parameter validation</span></div>
<div class="line">            <span class="keyword">with</span> pytest.raises(ValueError):</div>
<div class="line">                plugin.your_method(-1.0, [])  <span class="comment"># Invalid parameters</span></div>
<div class="line">            </div>
<div class="line">            <span class="comment"># Test that C++ exceptions become Python exceptions</span></div>
<div class="line">            <span class="keyword">with</span> pytest.raises(HeliosError):</div>
<div class="line">                plugin.your_method_that_might_fail(invalid_uuid=99999)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.native_only</span>  </div>
<div class="line"><span class="keyword">def </span>test_your_plugin_error_messages():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test that error messages are informative&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">with</span> Context() <span class="keyword">as</span> context:</div>
<div class="line">        <span class="keyword">with</span> YourPlugin(context) <span class="keyword">as</span> plugin:</div>
<div class="line">            <span class="keywordflow">try</span>:</div>
<div class="line">                plugin.problematic_method()</div>
<div class="line">                <span class="keyword">assert</span> <span class="keyword">False</span>, <span class="stringliteral">&quot;Should have raised an exception&quot;</span></div>
<div class="line">            <span class="keywordflow">except</span> HeliosError <span class="keyword">as</span> e:</div>
<div class="line">                <span class="comment"># Verify error message is helpful</span></div>
<div class="line">                error_msg = str(e).lower()</div>
<div class="line">                <span class="keyword">assert</span> any(keyword <span class="keywordflow">in</span> error_msg <span class="keywordflow">for</span> keyword <span class="keywordflow">in</span> </div>
<div class="line">                          [<span class="stringliteral">&quot;invalid&quot;</span>, <span class="stringliteral">&quot;not found&quot;</span>, <span class="stringliteral">&quot;failed&quot;</span>, <span class="stringliteral">&quot;error&quot;</span>])</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
Memory and Performance</h2>
<p><b>Large Data Handling:</b></p><ul>
<li>Use <code>numpy</code> arrays for large numerical datasets</li>
<li>Consider memory mapping for very large files</li>
<li>Implement progress callbacks for long-running operations</li>
</ul>
<p><b>Resource Cleanup:</b></p><ul>
<li>Always implement context managers (<code>__enter__</code>/<code>__exit__</code>)</li>
<li>Use weak references for callback registration</li>
<li>Ensure C++ objects are destroyed when Python objects are deleted</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Documentation Requirements</h2>
<p><b>Function Documentation Pattern:</b> </p><div class="fragment"><div class="line"><span class="keyword">def </span>your_function(param1: Type1, param2: Type2) -&gt; ReturnType:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Brief description of what the function does.</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    This function interfaces with the native Helios [PluginName] plugin to</span></div>
<div class="line"><span class="stringliteral">    perform [specific operation]. The computation is performed using [method]</span></div>
<div class="line"><span class="stringliteral">    and returns [description of results].</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    Args:</span></div>
<div class="line"><span class="stringliteral">        param1: Detailed description including units, ranges, constraints</span></div>
<div class="line"><span class="stringliteral">        param2: Detailed description with examples if complex</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">    Returns:</span></div>
<div class="line"><span class="stringliteral">        Detailed description of return value, including units and format</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">    Raises:</span></div>
<div class="line"><span class="stringliteral">        RuntimeError: When [specific condition causes failure]</span></div>
<div class="line"><span class="stringliteral">        ValueError: When [parameter validation fails]</span></div>
<div class="line"><span class="stringliteral">        NotImplementedError: When plugin not available in current build</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">    Example:</span></div>
<div class="line"><span class="stringliteral">        &gt;&gt;&gt; with Context() as context:</span></div>
<div class="line"><span class="stringliteral">        ...     plugin = YourPlugin(context)</span></div>
<div class="line"><span class="stringliteral">        ...     result = plugin.your_function(1.5, [1, 2, 3])</span></div>
<div class="line"><span class="stringliteral">        ...     print(f&quot;Computed values: {result}&quot;)</span></div>
<div class="line"><span class="stringliteral">        </span></div>
<div class="line"><span class="stringliteral">    Note:</span></div>
<div class="line"><span class="stringliteral">        This function requires the native Helios library built with </span></div>
<div class="line"><span class="stringliteral">        [PluginName] plugin support. In development mode, this will</span></div>
<div class="line"><span class="stringliteral">        raise NotImplementedError with instructions for building.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md19"></a>
Build System Integration</h2>
<p><b>Plugin Selection Integration:</b> The new flexible plugin system automatically handles plugin compilation based on user selection. Your plugin will be built when:</p>
<ol type="1">
<li><b>User explicitly selects it</b>: <code>--plugins your_plugin</code></li>
<li><b>Included in a profile</b>: Add to relevant profiles in <code><a class="el" href="plugin__profiles_8py.html">pyhelios/config/plugin_profiles.py</a></code></li>
<li><b>Required as dependency</b>: Another plugin lists it in <code>plugin_dependencies</code></li>
</ol>
<p><b>Dynamic Plugin Configuration:</b> The CMake system now uses <code>cmake/PluginSelection.cmake</code> to dynamically configure plugins:</p>
<div class="fragment"><div class="line"># Your plugin is automatically configured when selected</div>
<div class="line"># No need to manually modify CMakeLists.txt for basic plugins</div>
<div class="line"> </div>
<div class="line"># For complex plugins requiring special configuration:</div>
<div class="line">if(&quot;your_plugin&quot; IN_LIST PLUGINS)</div>
<div class="line">    # Add plugin-specific CMake configuration here</div>
<div class="line">    find_package(YourDependency REQUIRED)</div>
<div class="line">    target_link_libraries(your_plugin YourDependency::YourDependency)</div>
<div class="line">endif()</div>
</div><!-- fragment --><p><b>Runtime Plugin Detection:</b> Your plugin functions will be automatically detected at runtime using the <code>test_symbols</code> you specified in the metadata. The plugin registry will:</p>
<ol type="1">
<li>Check if your test functions are available in the loaded library</li>
<li>Mark the plugin as available/unavailable for Python code</li>
<li>Provide graceful error messages when unavailable</li>
<li>Enable automatic fallback behaviors</li>
</ol>
<p><b>User Experience Integration:</b> With the new system, users can easily discover and use your plugin:</p>
<div class="fragment"><div class="line"># Your plugin appears in discovery</div>
<div class="line">python -m pyhelios.plugins discover</div>
<div class="line"> </div>
<div class="line"># Users can get detailed information</div>
<div class="line">python -m pyhelios.plugins info your_plugin</div>
<div class="line"> </div>
<div class="line"># Users can build specifically with your plugin</div>
<div class="line">build_scripts/build_helios --plugins your_plugin</div>
<div class="line"> </div>
<div class="line"># Your plugin can be included in profiles</div>
<div class="line">build_scripts/build_helios --profile your_profile</div>
</div><!-- fragment --><p><b>Testing Integration:</b> Add your plugin to the comprehensive test suite:</p>
<div class="fragment"><div class="line"><span class="comment"># tests/test_your_plugin.py</span></div>
<div class="line"><span class="preprocessor">@pytest.mark.cross_platform</span></div>
<div class="line"><span class="keyword">def </span>test_your_plugin_metadata():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test plugin metadata is correctly defined&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">from</span> <a class="code hl_namespace" href="namespacepyhelios_1_1config_1_1plugin__metadata.html">pyhelios.config.plugin_metadata</a> <span class="keyword">import</span> get_plugin_metadata</div>
<div class="line">    metadata = get_plugin_metadata(<span class="stringliteral">&#39;your_plugin&#39;</span>)</div>
<div class="line">    <span class="keyword">assert</span> metadata <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line">    <span class="keyword">assert</span> metadata.description</div>
<div class="line">    <span class="keyword">assert</span> metadata.test_symbols</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.native_only</span>  </div>
<div class="line"><span class="keyword">def </span>test_your_plugin_functionality():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test actual plugin functionality with native library&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">with</span> Context() <span class="keyword">as</span> context:</div>
<div class="line">        <span class="keyword">with</span> YourPlugin(context) <span class="keyword">as</span> plugin:</div>
<div class="line">            result = plugin.your_method()</div>
<div class="line">            <span class="keyword">assert</span> result <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.cross_platform</span></div>
<div class="line"><span class="keyword">def </span>test_your_plugin_graceful_handling():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Test graceful handling when plugin unavailable&quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># Test that appropriate errors are raised with helpful messages</span></div>
<div class="line">    registry = get_plugin_registry()</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> registry.is_plugin_available(<span class="stringliteral">&#39;your_plugin&#39;</span>):</div>
<div class="line">        <span class="keyword">with</span> pytest.raises(PluginNotAvailableError, match=<span class="stringliteral">&quot;your_plugin&quot;</span>):</div>
<div class="line">            YourPlugin(context)</div>
<div class="ttc" id="anamespacepyhelios_1_1config_1_1plugin__metadata_html"><div class="ttname"><a href="namespacepyhelios_1_1config_1_1plugin__metadata.html">pyhelios.config.plugin_metadata</a></div><div class="ttdef"><b>Definition</b> <a href="plugin__metadata_8py_source.html#l00001">plugin_metadata.py:1</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md20"></a>
4. Critical Lessons Learned from Visualizer Integration</h1>
<h2><a class="anchor" id="autotoc_md21"></a>
Asset Management for Runtime Dependencies</h2>
<p><b>CRITICAL DISCOVERY</b>: Many C++ plugins require runtime assets (shaders, textures, fonts) that must be copied to specific locations where the C++ code expects to find them.</p>
<p><b>Problem Pattern:</b> C++ code often uses hardcoded relative paths to find assets: </p><div class="fragment"><div class="line"><span class="comment">// In C++ plugin code</span></div>
<div class="line">primaryShader.initialize(<span class="stringliteral">&quot;plugins/visualizer/shaders/primaryShader.vert&quot;</span>, </div>
<div class="line">                        <span class="stringliteral">&quot;plugins/visualizer/shaders/primaryShader.frag&quot;</span>, <span class="keyword">this</span>);</div>
</div><!-- fragment --><p><b>Solution Pattern:</b> The build system must copy these assets to the expected location relative to the PyHelios working directory.</p>
<p><b>Implementation in build_helios.py:</b> </p><div class="fragment"><div class="line"><span class="keyword">def </span>_copy_visualizer_assets(self) -&gt; None:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Copy all visualizer assets (shaders, textures, fonts) to the expected location.</span></div>
<div class="line"><span class="stringliteral">    </span></div>
<div class="line"><span class="stringliteral">    The C++ Visualizer code expects assets at &quot;plugins/visualizer/&quot; relative to the</span></div>
<div class="line"><span class="stringliteral">    working directory. This method copies all assets from the build directory to</span></div>
<div class="line"><span class="stringliteral">    the PyHelios directory structure where they can be found at runtime.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># Base paths</span></div>
<div class="line">    build_visualizer_dir = self.build_dir / <span class="stringliteral">&#39;plugins&#39;</span> / <span class="stringliteral">&#39;visualizer&#39;</span></div>
<div class="line">    target_base_dir = self.output_dir.parent / <span class="stringliteral">&#39;plugins&#39;</span> / <span class="stringliteral">&#39;visualizer&#39;</span></div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> build_visualizer_dir.exists():</div>
<div class="line">        print(f<span class="stringliteral">&quot;ℹ️  Visualizer assets directory not found: {build_visualizer_dir}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span></div>
<div class="line">    </div>
<div class="line">    total_files_copied = 0</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Copy shader files</span></div>
<div class="line">    build_shader_dir = build_visualizer_dir / <span class="stringliteral">&#39;shaders&#39;</span></div>
<div class="line">    <span class="keywordflow">if</span> build_shader_dir.exists():</div>
<div class="line">        target_shader_dir = target_base_dir / <span class="stringliteral">&#39;shaders&#39;</span></div>
<div class="line">        target_shader_dir.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> shader_file <span class="keywordflow">in</span> build_shader_dir.glob(<span class="stringliteral">&#39;*&#39;</span>):</div>
<div class="line">            <span class="keywordflow">if</span> shader_file.is_file():</div>
<div class="line">                dest_file = target_shader_dir / shader_file.name</div>
<div class="line">                shutil.copy2(shader_file, dest_file)</div>
<div class="line">                total_files_copied += 1</div>
<div class="line">                print(f<span class="stringliteral">&quot;Copied shader: {shader_file.name}&quot;</span>)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Copy texture files - preserve directory structure</span></div>
<div class="line">    build_texture_dir = build_visualizer_dir / <span class="stringliteral">&#39;textures&#39;</span></div>
<div class="line">    <span class="keywordflow">if</span> build_texture_dir.exists():</div>
<div class="line">        target_texture_dir = target_base_dir / <span class="stringliteral">&#39;textures&#39;</span></div>
<div class="line">        target_texture_dir.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> texture_file <span class="keywordflow">in</span> build_texture_dir.rglob(<span class="stringliteral">&#39;*&#39;</span>):</div>
<div class="line">            <span class="keywordflow">if</span> texture_file.is_file():</div>
<div class="line">                rel_path = texture_file.relative_to(build_texture_dir)</div>
<div class="line">                dest_file = target_texture_dir / rel_path</div>
<div class="line">                dest_file.parent.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">                shutil.copy2(texture_file, dest_file)</div>
<div class="line">                total_files_copied += 1</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Copy font files - preserve directory structure</span></div>
<div class="line">    build_font_dir = build_visualizer_dir / <span class="stringliteral">&#39;fonts&#39;</span></div>
<div class="line">    <span class="keywordflow">if</span> build_font_dir.exists():</div>
<div class="line">        target_font_dir = target_base_dir / <span class="stringliteral">&#39;fonts&#39;</span></div>
<div class="line">        target_font_dir.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> font_file <span class="keywordflow">in</span> build_font_dir.rglob(<span class="stringliteral">&#39;*&#39;</span>):</div>
<div class="line">            <span class="keywordflow">if</span> font_file.is_file():</div>
<div class="line">                rel_path = font_file.relative_to(build_font_dir)</div>
<div class="line">                dest_file = target_font_dir / rel_path</div>
<div class="line">                dest_file.parent.mkdir(parents=<span class="keyword">True</span>, exist_ok=<span class="keyword">True</span>)</div>
<div class="line">                shutil.copy2(font_file, dest_file)</div>
<div class="line">                total_files_copied += 1</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> total_files_copied &gt; 0:</div>
<div class="line">        print(f<span class="stringliteral">&quot;🎨 Successfully copied {total_files_copied} visualizer assets to {target_base_dir}&quot;</span>)</div>
</div><!-- fragment --><p><b>Integration into copy_to_output method:</b> </p><div class="fragment"><div class="line"><span class="keyword">def </span>copy_to_output(self, library_path: Path) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">    <span class="comment"># ... existing library copying code ...</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># Copy shader files and other assets for visualizer plugin</span></div>
<div class="line">    self._copy_visualizer_assets()</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># ... rest of method ...</span></div>
</div><!-- fragment --><p><b>Key Insights:</b></p><ol type="1">
<li><b>Check CMakeLists.txt for asset copying</b>: Look for <code>file(COPY ...)</code> and <code>add_custom_command</code> that copy assets during build</li>
<li><b>Assets may include</b>: Shaders (.vert, .frag), textures (.png, .jpg), fonts (.ttf), configuration files</li>
<li><b>Preserve directory structure</b>: Some plugins expect assets in specific subdirectories</li>
<li><b>Build-time vs Runtime paths</b>: Assets are copied during build to one location, but must be accessible at runtime from working directory</li>
</ol>
<h2><a class="anchor" id="autotoc_md22"></a>
Constructor Parameter Mapping Issues</h2>
<p><b>CRITICAL DISCOVERY</b>: C++ function signatures must be precisely mapped to Python parameters, especially for constructor overloads.</p>
<p><b>Problem Pattern:</b> The C++ Visualizer constructor signature was: </p><div class="fragment"><div class="line">Visualizer(width, height, antialiasing_samples, window_decorations, headless)</div>
</div><!-- fragment --><p>But the C interface was incorrectly mapping parameters: </p><div class="fragment"><div class="line"><span class="comment">// WRONG - semantically incorrect parameter mapping</span></div>
<div class="line">Visualizer* createVisualizer(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height, <span class="keywordtype">bool</span> window_decorations) {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Visualizer(width, height, 4, window_decorations, <span class="keyword">false</span>); <span class="comment">// headless hardcoded as false</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This caused <code>headless=False</code> (Python default) to be passed as <code>window_decorations=false</code>, disabling window decorations.</p>
<p><b>Solution Pattern:</b> </p><div class="fragment"><div class="line"><span class="comment">// CORRECT - proper semantic mapping</span></div>
<div class="line">Visualizer* createVisualizer(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> height, <span class="keywordtype">bool</span> headless) {</div>
<div class="line">    <span class="comment">// Enable window decorations by default (true), headless parameter controls window visibility</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> Visualizer(width, height, 4, <span class="keyword">true</span>, headless); <span class="comment">// decorations=true, headless passed correctly</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Key Insights:</b></p><ol type="1">
<li><b>Always check the actual C++ constructor signature</b>: Don't assume parameter order or meaning</li>
<li><b>Semantic mapping matters</b>: Parameter names should reflect their actual purpose</li>
<li><b>Default values in C interface</b>: Choose sensible defaults for optional C++ parameters</li>
<li><b>Test different parameter combinations</b>: Verify that parameter mapping produces expected behavior</li>
</ol>
<h2><a class="anchor" id="autotoc_md23"></a>
Library Linking and Symbol Resolution</h2>
<p><b>CRITICAL DISCOVERY</b>: Static libraries require special handling on macOS to ensure all symbols are included in the shared library.</p>
<p><b>Problem Pattern:</b> When converting static libraries to shared libraries, some plugin symbols were missing due to dead code elimination.</p>
<p><b>Solution Pattern:</b> </p><div class="fragment"><div class="line"># macOS: Use -Wl,-force_load to include all symbols from static libraries</div>
<div class="line">cmd = [</div>
<div class="line">    &#39;clang++&#39;, &#39;-dynamiclib&#39;, &#39;-o&#39;, str(output_path),</div>
<div class="line">    &#39;-Wl,-force_load&#39;, str(cleaned_libs[&#39;main&#39;]),  # Force load main library</div>
<div class="line">    # ... other libraries ...</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line"># Include cleaned plugin libraries with force_load</div>
<div class="line">for lib_path in cleaned_libs[&#39;plugins&#39;]:</div>
<div class="line">    cmd.extend([&#39;-Wl,-force_load&#39;, str(lib_path)])</div>
<div class="line">    print(f&quot;Including cleaned plugin library: {lib_path.name}&quot;)</div>
</div><!-- fragment --><p><b>Key Insights:</b></p><ol type="1">
<li><b>Static library symbol inclusion</b>: Use appropriate linker flags to ensure all symbols are included</li>
<li><b>Cross-platform differences</b>: Linux uses different flags than macOS for similar functionality</li>
<li><b>Plugin dependencies</b>: Some plugins depend on other plugins and need proper linking order</li>
<li><b>Symbol visibility</b>: Ensure C interface functions are exported with proper visibility</li>
</ol>
<h2><a class="anchor" id="autotoc_md24"></a>
Plugin Function Availability Detection</h2>
<p><b>CRITICAL DISCOVERY</b>: Plugin functionality must be properly detected at runtime to provide graceful fallbacks.</p>
<p><b>Problem Pattern:</b> Code assumed plugin functions were available without checking, leading to AttributeError crashes.</p>
<p><b>Solution Pattern:</b> </p><div class="fragment"><div class="line"><span class="comment"># Proper availability detection in wrappers</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    helios_lib.createVisualizer.argtypes = [ctypes.c_uint32, ctypes.c_uint32, ctypes.c_bool]</div>
<div class="line">    helios_lib.createVisualizer.restype = ctypes.POINTER(UVisualizer)</div>
<div class="line">    <span class="comment"># ... other function prototypes ...</span></div>
<div class="line">    _VISUALIZER_FUNCTIONS_AVAILABLE = <span class="keyword">True</span></div>
<div class="line"><span class="keywordflow">except</span> AttributeError:</div>
<div class="line">    _VISUALIZER_FUNCTIONS_AVAILABLE = <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Graceful error handling</span></div>
<div class="line"><span class="keyword">def </span>create_visualizer(width: int, height: int, headless: bool = <span class="keyword">False</span>):</div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> _VISUALIZER_FUNCTIONS_AVAILABLE:</div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError(</div>
<div class="line">            <span class="stringliteral">&quot;Visualizer functions not available in current Helios library. &quot;</span></div>
<div class="line">            <span class="stringliteral">&quot;Rebuild with visualizer plugin enabled.&quot;</span></div>
<div class="line">        )</div>
<div class="line">    <span class="comment"># ... actual function implementation ...</span></div>
</div><!-- fragment --><p><b>Key Insights:</b></p><ol type="1">
<li><b>Always check function availability</b>: Use try/except around ctypes function prototype declarations</li>
<li><b>Provide actionable error messages</b>: Tell users exactly how to fix the problem</li>
<li><b>Mock mode fallbacks</b>: Consider providing mock implementations for development</li>
<li><b>Plugin interdependencies</b>: Some plugins may depend on others being available</li>
</ol>
<h2><a class="anchor" id="autotoc_md25"></a>
Build System Integration Best Practices</h2>
<p><b>CRITICAL DISCOVERY</b>: The build system must handle plugin assets, dependencies, and cross-platform differences automatically.</p>
<p><b>Key Requirements:</b></p><ol type="1">
<li><b>Asset copying must be automatic</b>: No manual user intervention should be required</li>
<li><b>Cross-platform compatibility</b>: Handle different file extensions and paths on different platforms</li>
<li><b>Dependency management</b>: Automatically handle plugin-specific dependencies (OpenGL, CUDA, etc.)</li>
<li><b>Library validation</b>: Test that built libraries can actually be loaded by ctypes</li>
</ol>
<p><b>Implementation Pattern:</b> </p><div class="fragment"><div class="line"><span class="keyword">def </span>copy_to_output(self, library_path: Path) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">    <span class="comment"># 1. Copy main library</span></div>
<div class="line">    <span class="comment"># 2. Validate library is loadable by ctypes (fail-fast)</span></div>
<div class="line">    self._validate_library_loadable(output_path)</div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 3. Copy plugin-specific assets</span></div>
<div class="line">    self._copy_plugin_assets()  <span class="comment"># New requirement</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment"># 4. Handle platform-specific files</span></div>
<div class="line">    <span class="keywordflow">if</span> self.platform_name == <span class="stringliteral">&#39;Windows&#39;</span>:</div>
<div class="line">        <span class="comment"># Copy PDB files, etc.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md26"></a>
Error Manifestation Patterns</h2>
<p><b>CRITICAL INSIGHTS</b>: Different types of integration problems manifest as different error patterns:</p>
<ol type="1">
<li><b>Missing C Interface Functions</b>: <code>AttributeError</code> when setting ctypes prototypes<ul>
<li><b>Solution</b>: Add functions to <code>pyhelios_interface.cpp</code> and rebuild</li>
</ul>
</li>
<li><b>Asset Loading Failures</b>: Runtime crashes with OpenGL/shader errors<ul>
<li><b>Solution</b>: Implement asset copying in build system</li>
</ul>
</li>
<li><b>Parameter Mapping Issues</b>: Unexpected behavior (wrong window decorations, etc.)<ul>
<li><b>Solution</b>: Carefully check C++ function signatures and map parameters correctly</li>
</ul>
</li>
<li><b>Library Loading Failures</b>: <code>OSError</code> when ctypes tries to load library<ul>
<li><b>Solution</b>: Check library dependencies and linking</li>
</ul>
</li>
<li><b>Symbol Resolution Failures</b>: Functions appear available but crash when called<ul>
<li><b>Solution</b>: Use proper linker flags (<code>-Wl,-force_load</code> on macOS)</li>
</ul>
</li>
</ol>
<p>This guide provides the foundation for integrating additional C++ plugins with PyHelios's new flexible plugin system. The new architecture provides automatic plugin discovery, user-friendly configuration, and comprehensive error handling while maintaining consistency across the codebase.</p>
<h1><a class="anchor" id="autotoc_md27"></a>
Complete Integration Workflow</h1>
<p>For the complete step-by-step plugin integration process, including:</p><ul>
<li>Plugin metadata registration</li>
<li>Build system integration <br  />
</li>
<li>Python wrapper creation</li>
<li>Testing and documentation</li>
<li>Asset management</li>
</ul>
<p><b>See the comprehensive Plugin Integration Guide</b></p>
<h1><a class="anchor" id="autotoc_md28"></a>
Key Lessons from Plugin Integration Experience</h1>
<p><b>The radiation, visualizer, and WeberPennTree integration experiences revealed that plugin integration requires attention to:</b></p>
<ol type="1">
<li><b>Runtime asset management</b> - copying shaders, textures, fonts to expected locations</li>
<li><b>Precise parameter mapping</b> - matching C++ constructor signatures exactly <br  />
</li>
<li><b>Library symbol inclusion</b> - ensuring all plugin symbols are properly linked</li>
<li><b>Graceful availability detection</b> - providing clear error messages when plugins are missing</li>
<li><b>Automated build system integration</b> - handling all dependencies and assets automatically</li>
<li><b>Exception handling patterns</b> - proper C++ to Python exception translation</li>
<li><b>Cross-platform compatibility</b> - different linking and symbol export requirements</li>
<li><b>Plugin interdependencies</b> - managing complex dependency relationships</li>
</ol>
<h1><a class="anchor" id="autotoc_md29"></a>
Integration Phases Overview</h1>
<p>The complete plugin integration process involves <b>8 distinct phases</b>:</p>
<ol type="1">
<li><b>Plugin Metadata Registration</b> - Add to registry and profiles</li>
<li><b>Build System Integration</b> - CMake and dependency management</li>
<li><b>C++ Interface Implementation</b> - Add wrapper functions (this guide's focus)</li>
<li><b>ctypes Wrapper Creation</b> - Python-to-C++ interface layer</li>
<li><b>High-Level Python API</b> - User-friendly classes with error handling</li>
<li><b>Asset Management</b> - Runtime asset copying and discovery</li>
<li><b>Testing Integration</b> - Cross-platform test coverage <br  />
</li>
<li><b>Documentation</b> - API docs and usage examples</li>
</ol>
<p>This guide focuses on <b>Phase 3</b> (C++ Interface Implementation). For complete coverage of all phases, see the Plugin Integration Guide.</p>
<p>These lessons and structured approach will significantly accelerate future plugin integration efforts while maintaining PyHelios's high standards for cross-platform compatibility and user experience. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
